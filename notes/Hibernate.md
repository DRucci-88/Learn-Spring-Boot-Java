A Framework for persisting / saving Java objects in a database
Used as Vendor Implementation for JPA
Default JPA implementation in Spring Boot


Benefits
- Handles all of the low-level SQL
- Minimizes the amount of JDBC code you have to develop
- Provides the Object to Relational Mapping (ORM)

## ORM
Object Relational Mapping
- Defines mapping between Java class and database table
- Java class will map to given table
- Setup this mapping via configuration file using XML or Java annotation
- 

## JPA
Jakarta Persistence API
- Standart API for ORM
- Only a specification
	- Defines a set of interfaces
	- Requires an implementation to be usable

Benefits :
- By having a standart API, you are not locked to vendor's implementation
- Maintain portable, flexible code by coding to JPA spec (interfaces)
- Can theoritically switch vendor implemtation
	- For example, if vendor ABC stops supporting their product
	- You could switch to vendor XYZ without vendor lock in
- Why not vendor lock in ? because we are coding to the actual JPA specification or the Standart API

### Terminology :
- Entity Class 
	- Java class that is mapped to a database table
	- Must be annotated with `@Entity`
	- Must have a public / protected no-argiment constructor
		- The class can have other constructors
- Primary Key
	- Uniquely identifies each row in a table
	- Must be a unique value
	- Cannot contain NULL values

### JPA Java Annotations :
1. Map class to database table
	- `@Entity`
	- `@Table(name="student")`
	- 
1. Map fields to database columns
	- `@id`
	- `@Column(name="id")`
	- `@GeneratedValue(strategy=GenerationType.IDENTITY)`
		- it's value will be generated by the database and managed by database / generated value

### JPA Entity Manager
- Our JPA Entity Manager needs a Data Source
- The data source defines database connection info
- JPA Entity Manager and Data Source are automatically created by Spring Boot
	- Based on the file: application.properties
- We can autowire / inject the JPA Entity Manager into our class DAO 

### JPQL
JPA Query Language
- Query language for retrieving objects
- Similar in concept to SQL
	- where, like, order by, join, in, etc...
- Based on `entity name` and `entity fields`
	- as opposed to the direct table names and table columns

### Create database tables
- Create tables based on Java code with JPA / Hibernate annotations
- Useful for development and testing
- Java Code -> JPA / Hibernate -> SQL -> Database
- Based on our `@Entity` Annotation

Configuration : 
- Spring boot configuration file: `application.properties`
	- `spring.jpa.hibernate.ddl-auto=create`
- When you run your app, JPA / Hibernate will DROP tables then CREATE them
- Based on JPA / Hibernate annotations in your Java code

### spring.jpa.hibernate.ddl-auto=[property-value]
Do not `property-value = create` on production Database !!! We do not want to DROP your production data (All data is deleted) 
property-value : 
- none 
	- No action will be performed
- create-only
	- Database tables are only created
- drop
	- Database tables are dropped
- create
	- Database tables are dropped followed by database tables creation
- create-drop
	- Database tables are dropped followed by database tables creation
	- On application shutdown, drop the database tables
- validate
	- Validate the database tables shema
- update
	- Update the database tables shema
	- So if you add any new fields to your entity, it will provide the approriate updates on the given databse tables

Use Case `property-value = create` :
- Automatic table generation is usefull for
	- Database integration testing with in-memory databases
	- Basic, small hobby projects

Recommendation :
- In general, not recommended auto generation for enterprise or real time projects
	- You van very easily drop PRODUCTION data if you are not careful
- SQL Scripts is BEST
	- Corporate DBAs prefer SQL scripts for goverance and code review
	- SQL scripts can be customized and fine-tuned for complex database designs
	- SQL scripts can be version-controlled
	- Can also work with scheme migration tools such as `Liquibase` and `Flyway`

## DAO
Data Access Object
- Responsible for interacting with the database
- Common design pattern
- Like a data class to communicate with the database
- DAO needs a JPA Entity Manager
- JPA Entity Manager is the main component for saving / retrieving entities

Example of Student DAO
1. Define DAO interface
2. Define DAO implemantation
	- Inject the entity manager
3. Update main app

### @Transactional
- Automagically begin and end a transaction for your JPA code
- No need for your explicitly do this in your code

### @Repository
- sub-annotation from `@Component`
- Applied to DAO implementations
- Automatically register the DAO implementation
	- Thanks to component-scanning
- Provides transalation of any JDBC related exceptations

## MySQL Database
MySQL includes two components
- MySQL Database Server
	- Main engine of the database
	- Stores data for the database
	- Supports CRUD features on the data
- MySQL Workbench 
	- MySQL workbench is a client GUI for interacting with the database
	- Create database shemas and tables
	- Execute SQL queries to retrieve data
	- Perform insert, updates and deletes on data
	- Handle adminstrative functions such as creating users

